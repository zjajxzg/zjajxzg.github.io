---
title: 策略模式
date: 2020-03-17 23:15:21
categories: 设计模式
tags: 设计模式
description: 不得不会的设计模式-策略模式
---

### 策略模式

------

#### 背景：

​	相信大家在写业务需求的时候总会遇到这样的情况，根据前端传的参数来区分不同的场景来执行不同的任务，于是就有了下面的代码：

```java
// 场景A
if (A) {
    // do some things...
} else if (B) {
    // do some things...
} else if (C) {
    // ...
}
```

<!-- more -->

当业务场景不多的情况下，这样的代码我们还能接受，但是一旦业务场景越来越复杂，可能会有10多个场景，你会发现这里会形成if...else...噩梦，这个时候就可以用策略模式来消除if-else。

#### 策略模式介绍

##### 1、什么是策略模式

> 策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户

##### 2、策略模式UML图

![](https://raw.githubusercontent.com/zjajxzg/figure_bed_public/master/github_img/design_pattern_strategy_uml.png)

##### 3、策略模式实现

关于策略模式的实现方式有很多种，下面我来介绍一种我在平时开发中比较常用的形式，枚举+spring+策略:

​		这里使用的业务场景是电商业务下，app上打开商品详情会有很多入口，不同的入口看到的商品发货体可能会有不同的计算方式，这些计算方式就对应着前面策略模式所说的算法，其实就对应着一个个策略

1、定义场景枚举

```java
@Getter
@AllArgsConstructor
public enum BingoShopStrategyEnum {
    /**
     * 商品详情（正常入口，搜索列表之类）
     */
    GOODS_DETAIL(1, "goodsDetailStrategy", "商品详情"),

    /**
     * 商品详情（订单详情入口）
     */
    GOODS_DETAIL_ORDER(2, "goodsDetailOrderStrategy", "商品详情订单入口"),

    /**
     * 商品详情（商品详情切换地址）
     */
    GOODS_DETAIL_CHANGE_ADDR(3, "goodsDetailChangeAddrStrategy", "商品详情切换地址"),

    /**
     * 商品详情(分享)
     */
    GOODS_DETAIL_SHARE(4, "goodsDetailShareStrategy", "商品详情分享"),

    /**
     * 商品详情小程序
     */
    GOODS_DETAIL_MINI_PROGRAM_LIVE(5, "goodsDetailMiniProgramLiveStrategy", "商品详情小程序"),

    /**
     * 结算/购物车
     */
    CART(6, "cartStrategy", "结算/购物车");

    private int code;

    /**
     * 策略beanName
     */
    private String strategyBean;

    /**
     * 场景
     */
    private String scenes;

    /**
     * 根据code获取枚举
     *
     * @param code
     * @return
     */
    public static BingoShopStrategyEnum getByCode(int code) {
        return Arrays.stream(values()).filter(bingoShopStrategyEnum -> bingoShopStrategyEnum.code == code)
                .findFirst()
                .orElse(null);
    }
}
```

2、定义策略类（接口或者抽象类）

```java
@slfj
@Service
public abstract class BaseBingoShopStrategy {
    
	/**
     * 计算方法
     */
    public abstract List<GoodsBingoShopDTO> calBingoShop();
}
```

3、具体实现类

```java
@Service("goodsDetailStrategy")
public class GoodsDetailStrategy extends BaseBingoShopStrategy {
    /**
     * 计算方法
     */
    @Override
    public List<GoodsBingoShopDTO> calBingoShop() {
        // 具体逻辑
    };
}
```

4、调用策略（只需要根据前端传来的code值去获取对应的策略类，从而走不同的算法）

```java
@Slf4j
@Service
public class BingoShopServiceImpl implements BingoShopService {

    @Override
    public List<GoodsBingoShopDTO> getBingoShop(QueryBingoShopForm queryBingoShopForm) {
        //...
        // 获取当前场景对应的策略
        BaseBingoShopStrategy baseBingoShopStrategy = (BaseBingoShopStrategy) SpringUtil.getBean(BingoShopStrategyEnum.getByCode(queryBingoShopForm.getCode()).getStrategyBean());
        // 计算最优门店
        goodsBingoShopDTOList = baseBingoShopStrategy.calBingoShop();
		//...
 
}
```

5、SpringUtil代码补充（利用spring的ApplicationContext来获取策略对象实例Bean）

```java
@Component
public class SpringUtil implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        SpringUtil.applicationContext = applicationContext;
    }

    /**
     * 根据beanName获取bean
     *
     * @param name
     * @return
     */
    public static Object getBean(String name) {
        return applicationContext.getBean(name);
    }
}
```

##### 4、总结

以上就是一个完整的策略模式实例，是不是比一坨的if-else更清晰呢，下面我们分析一下策略模式的优缺点

优点：

- 遵循开闭原则，对拓展开放，一旦需要新增场景，只需要新增实现类和对应的场景枚举（这个只是我这种形式会用到）即可，不需要对客户端调用的代码进行修改。

- 代码更清晰，不同的算法之间没有直接关联，相比在一个方法中写满了if-else可读性更好，修改起来也更方便。

缺点：

- 策略越来越多的时候类也越来越多，几乎不会复用
- 调用方必须知道所有的策略类，并自行决定使用哪一个策略（不同的场景具体传什么code）



策略模式算是平时开发中比较常用也比较实用的设计模式了，相信看完文章的你应该已经可以轻松掌握了吧！



参考资料：

《大话设计模式》

《策略模式原来这么简单》https://juejin.im/post/5c25b8bcf265da61117a5ea1#heading-4